package utils;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import models.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;

/**
 * Contains the methods for fetching data from the Database into ObservableLists, and interacting with the
 * ObservableLists.
 * @author Christian Dewey
 */
public class DataAccessRead {

    private static final ObservableList<Appointment> appointmentList = FXCollections.observableArrayList();

    /**
     * Gets the appointmentList.
     */
    public static ObservableList<Appointment> getAppointmentList() { return appointmentList; }

    private static int lastAppointmentId;

    /**
     * Gets lastAppointmentId, used for setting the next appointmentId.
     */
    public static int getLastAppointmentId() { return lastAppointmentId; }

    /**
     * Adds the input Appointment into the appointmentList and increments lastAppointmentId.
     * @param a the appointment to add.
     */
    public static void addToAppointmentList(Appointment a) { appointmentList.add(a); lastAppointmentId++; }

    /**
     * The input Appointment replaces the existing appointment in the appointmentList.
     * @param a the Appointment to update.
     */
    public static void updateAppointment(Appointment a) {
        int index = 0;
        for (int i = 0; i < appointmentList.size(); i++) {
            if (appointmentList.get(i).getId() == a.getId()) {
                index = i;
                break;
            }
        }
        appointmentList.set(index, a);
    }

    /**
     * Queries the Database for all appointments, then passes them all into the ObservableList named appointmentList.
     */
    public static void fetchAppointmentData() {
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT * FROM appointments";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {
                LocalDateTime createDate = rs.getTimestamp("Create_Date").toLocalDateTime();

                Appointment apt = new Appointment(
                        rs.getInt("Appointment_ID"),
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        TimeUtility.DisplayInLocalTime(rs.getTimestamp("Start")),
                        TimeUtility.DisplayInLocalTime(rs.getTimestamp("End")),
                        createDate,
                        rs.getString("Created_By"),
                        rs.getTimestamp("Last_Update"),
                        rs.getString("Last_Updated_By"),
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID")
                );

                appointmentList.add(apt);
                lastAppointmentId = rs.getInt("Appointment_ID");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
    * This method is to be called only after an appointment has successfully been deleted from the MySQL Database.
    *   Occasionally if many appointments are added and deleted, the lastAppointmentId does not match the Appointment ID
    *   generated by MySQL Database until the application is restarted.
    *   To overcome this issue, if the appointmentId of the appointment is not found in the list, the appointmentList
    *   is cleared and fetchAppointmentData() is called again.
    */
    public static void removeAppointmentFromList(Appointment appointmentToRemove) {
        if (appointmentList.contains(appointmentToRemove)) {

            for (Appointment a : appointmentList) {
                if (a.getId() == appointmentToRemove.getId()) {
                    appointmentList.remove(a);
                    break;
                }
            }

        } else {
            appointmentList.clear();
            fetchAppointmentData();
        }
    }

    /**
     * @return the String form of the location of the customer - includes the Country and First-Level-Division.
     * @param divisionId the divisionId from the Customer record.
     */
    private static String getLocation(int divisionId) {
        StringBuilder location = null;
       try {
           Connection connection = DBConnection.getConnection();
           String selectStatement = "SELECT Division_ID, Division, Country_ID FROM first_level_divisions WHERE Division_ID = ?";

           DBQuery.setPreparedStatement(connection, selectStatement);
           PreparedStatement ps = DBQuery.getPreparedStatement();

           ps.setString(1, Integer.toString(divisionId));

           ps.execute();

           ResultSet rs = ps.getResultSet();

           while (rs.next()) {
               location = new StringBuilder(rs.getString("Division") + ", ");

               String selectStatement1 = "SELECT Country_ID, Country FROM countries WHERE Country_ID = ?";
               DBQuery.setPreparedStatement(connection, selectStatement1);
               PreparedStatement ps1 = DBQuery.getPreparedStatement();

               ps1.setString(1, rs.getString("Country_ID"));

               ps1.execute();

               ResultSet rs1 = ps1.getResultSet();
               while (rs1.next()) {
                   location.append(rs1.getString("Country"));
               }
           }
       } catch (SQLException e) {
           e.printStackTrace();
       }

        assert location != null;
        return location.toString();
    }

    private static ObservableList<Customer> customerList = FXCollections.observableArrayList();

    /**
     * Gets the customerList
     */
    public static ObservableList<Customer> getCustomerList() { return customerList; }

    private static int lastCustomerId;

    /**
     * Gets lastCustomerId used for setting the next Customer ID.
     */
    public static int getLastCustomerId() { return lastCustomerId; }

    /**
     * Adds the input Customer to the customerList, and increments lastCustomerId.
     * @param c the Customer to add.
     */
    public static void addToCustomerList(Customer c) { customerList.add(c); lastCustomerId++; }

    /**
     * The input Customer replaces the existing Customer in the customerList.
     * @param c the Customer to update.
     */
    public static void updateCustomer(Customer c) {
        int index = 0;
        for (int i = 0; i < customerList.size(); i++) {
            if (customerList.get(i).getId() == c.getId()) {
                index = i;
                break;
            }
        }
        customerList.set(index, c);
    }

    /**
     * Queries the Database for all customers, then passes them all into the ObservableList named customerList.
     */
    public static void fetchCustomerData() {
        customerList = FXCollections.observableArrayList();
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT * FROM customers";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {
                String location = getLocation(rs.getInt("Division_ID"));


                Customer customer = new Customer(

                        rs.getInt("Customer_ID"),
                        rs.getString("Customer_Name"),
                        rs.getString("Address"),
                        rs.getString("Postal_Code"),
                        rs.getString("Phone"),
                        rs.getTimestamp("Create_Date").toLocalDateTime(),
                        rs.getString("Created_By"),
                        rs.getTimestamp("Last_Update"),
                        rs.getString("Last_Updated_By"),
                        rs.getInt("Division_ID"),
                        location
                );
                customerList.add(customer);
                lastCustomerId = rs.getInt("Customer_ID");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * This method is to be called only after a customer has successfully been deleted from the MySQL Database.
     *  Occasionally if many customers are added and deleted, the lastCustomerId does not match the Customer ID
     *  generated by MySQL Database until the application is restarted.
     *  To overcome this issue, if the customerId of the customer is not found in the list, the customerList
     *  is cleared and fetchCustomerData() is called again instead.
     */
    public static void removeCustomerFromList(Customer customerToRemove) {
        for (int i = 0; i < customerList.size(); i++) {
            if (customerList.get(i).getId() == customerToRemove.getId()) {
                customerList.remove(i);
                break;
            }
        }
    }

    private static ObservableList<Contact> contactList = FXCollections.observableArrayList();

    /**
     * Gets the contactList.
     */
    public static ObservableList<Contact> getContactList() { return contactList; }

    /**
     * Queries the Database for all Contacts, then passes them all into the ObservableList named contactList.
     */
    public static void fetchContactData() {
        contactList = FXCollections.observableArrayList();
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT * FROM contacts";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {
                Contact contact = new Contact(

                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name"),
                        rs.getString("Email")
                );
                contactList.add(contact);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static final ObservableList<Country> countryList = FXCollections.observableArrayList();

    /**
     * Gets the countryList.
     */
    public static ObservableList<Country> getCountryList() { return countryList; }

    /**
     * Queries the Database for all Countries, then passes them all into the ObservableList named countryList.
     */
    public static void fetchCountryData() {
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT * FROM countries";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {

                Country c = new Country(
                        rs.getInt("Country_ID"),
                        rs.getString("Country")
                );

                countryList.add(c);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static final ObservableList<FirstLvlDivision> divisionList = FXCollections.observableArrayList();

    /**
     * Gets the divisionList.
     */
    public static ObservableList<FirstLvlDivision> getDivisionList() { return divisionList; }

    /**
     * Queries the Database for all First-Level-Divisions,
     *  then passes them all into the ObservableList named divisionList.
     */
    public static void fetchDivisionData() {
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT * FROM first_level_divisions";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {

                FirstLvlDivision d = new FirstLvlDivision(
                        rs.getInt("Division_ID"),
                        rs.getString("Division"),
                        rs.getInt("Country_ID")
                );

                divisionList.add(d);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static final ObservableList<User> userList = FXCollections.observableArrayList();

    /**
     * Gets the userList.
     */
    public static ObservableList<User> getUserList() { return userList; }

    /**
     * Queries the Database for all users, by User_ID only, then passes them all into the ObservableList named userList.
     */
    public static void fetchUserData() {
        try {
            Connection connection = DBConnection.getConnection();
            String selectStatement = "SELECT User_ID FROM users";

            DBQuery.setPreparedStatement(connection, selectStatement);
            PreparedStatement ps = DBQuery.getPreparedStatement();

            ps.execute();

            ResultSet rs = ps.getResultSet();

            // Forward Scroll ResultSet
            while (rs.next()) {

                User u = new User(
                        rs.getInt("User_ID")
                );

                userList.add(u);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}